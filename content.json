[{"title":"jQuery 事件","date":"2016-07-19T16:00:00.000Z","path":"2016/07/20/JavaScript-16  jQuery03/","text":"attr方法 attr()方法:可以设置属性值,两个参数:1.属性名字,2,属性值 attr()方法:可以获取属性值,一个参数:1.属性名字prop方法 使用同attr方法,prop()方法可以设置或者获取标签的属性值,而且可以获取复选框checked的true或者false值; 设置和获取元素的宽和高//直接设置数字的值即可: $(“div”).width(500); 位置操作 Offset()方法返回的是对象,并且,对象中有一个left和一个top,并且值是数字类型 设置的时候也可以没有px 设置的时候元素在设置前如果没有脱离文档流,设置的时候会自动进行脱离文档流,默认为relative 如果设置前有脱离文档流,那么设置的时候直接改变位置 注意:如果层和层中的标签(p)同时定位,并且,p距离左上角50px.通过按钮设置层距离左上角100px,那么p此时距离左上角为150px scrollLeft()和scrollTop() 用法和之前的offset()方法类似,获取的是数字,设置可以在括号中添加值即可;12345678910$(function () &#123; $(window).scroll(function () &#123; var h=$(\".top\").height(); var top=$(window).scrollTop(); if(top&gt;=h)&#123; $(\".nav\").css(&#123;\"position\":\"fixed\",\"top\":0&#125;); //此时main为固定定位，所以设置margin-top $(\".main\").css(&#123;\"marginTop\":$(\".nav\").height()&#125;); &#125;else&#123; $(\".nav\").css(&#123;\"position\":\"static\"&#125;); //此时main为固定定位，所以设置margin-top $(\".main\").css(&#123;\"marginTop\":0&#125;); &#125; &#125;); &#125;); 绑定事件 第一种: 对象.事件名字(匿名函数); 举例子: $(“#btn”).click(function(){}); 第二种: 对象.bind(事件的类型,匿名函数); 举例子: $(“#btn”).bind(“click”,function(){}); $(“#btn”).bind({“事件”:匿名函数,”事件”:匿名函数}); 第三种: 父级元素对象.delegate(子级元素对象,事件的类型,匿名函数); 举例子: $(“div”).delegate(“p”,”click”,function(){}) delegate()方法内部调用的是on()这个方法实现的 第四种: 父级元素对象.on(事件的类型,子级元素对象,匿名函数); 举例子:$(“div”).on(“click”,”p”,function(){}); 但是.on()方法也可以这么写 对象.on(事件的类型,匿名函数); 举例子:$(“#btn”).on(“click”,function(){});解除绑定事件: bind()绑定用unbind()解除 delegate()绑定用undelegate()解除 on()绑定用off()解除触发事件 1.对象.事件名(); 2.对象.trigger(“事件名”); 前两种触发事件会触发浏览器的默认事件,下面的不会 3.对象.triggetHanele(“事件名”);事件对象可以调用keycode属性获取键的值在jquery中阻止事件冒泡可以用return false return false可以取消浏览器的默认事件链式编程原理,就是在对象方法内部返回了当前对象","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery 常用操作","date":"2016-07-14T16:00:00.000Z","path":"2016/07/15/JavaScript-15  jQuery02/","text":"jQuery样式操作问题 DOM中不能获取元素的属性值 jQuery中可以获取属性的值，$(),括号里如果只写属性，获取的是属性的值 通过类样式操作元素 .addclass(“类样式的名字”)方法为元素添加类样式，可以在该方法中添加多个类样式，中间用空格隔开 .removeclass(“类样式的名字”)方法为元素删除类样式，可以在该方法中删除多个类样式，中间用空格隔开，如果该方法内部没有参数，则删除的是全部的类样式 * .hasClass方法 判断当前元素是否应用了指定的类样式,返回值是布尔类型 * .toggleClass（“类样式的名字”）切换类样式 （开关灯案例） 链式编程 只有当前调用该方法的是一个对象才能继续链式编程 对象调用方法后,如果返回的还是调用该方法的对象,那么可以继续的链式编程 如果对象调用方法后,返回的不是对象,那么此时就不能链式编程了 什么时候返回的是对象,什么时候不是 不太严禁的总结:对象调用方法的时候,进行了设置,那么一般返回的都是对象,如果是获取,那么一般返回的都是获取的内容而不是对象方法补充 .next() 获取当前元素下一个兄弟元素 .nextAll() 获取当前元素下面所有的兄弟元素 .prev() 获取当前元素前一个兄弟元素 .prevtAll() 获取当前元素前面所有的兄弟元素 .siblings() 获取当前元素的所有兄弟元素，不包括自己 .end() 修复断链方法 .last() 获取最后一个元素 :last 获取最后一个元素动画的方法 .show()方法 显示 .hide()方法 隐藏 .slideDown()方法 滑出–显示 .shideUp()方法 滑入–隐藏 .fadeIn()方法 淡出–显示 .fadeout()方法 淡入–隐藏 参数问题 参数可以是一个数字，可以是一个字符串（slow,normal,fast） 参数也可以是两个，第一个是数字或字符串，第二个是一个函数 animate 参数1：键值对 参数2：时间 参数3：函数 .stop() 停止当前的动画arguments.callee 主要是递归，可以调用所在的函数，注意：新版本的标准中不是很推荐使用动态的创建元素 .html(“这是一个p“）) .append()添加方法，追加 $(“div”).append($(“哈哈“)) .appendTo()被添加 $(“哈哈“).appendTo($(“div”))清空 .html(“”);清空 .empty();清空 .remove();自杀了—当前元素移除了表单val()方法的使用 textarea文本域, 可以使用.val方法也可以使用.text方法 在DOM中如果是获取文本域的内容,使用value属性，如果是设置文本域的内容,最好使用innerText jQuery中设置和获取文本域的内容最好使用text()方法 设置某个下拉框选中 .val()方法针对下拉框的内容选中的时候,方法中传入的是某个option的value属性值 $(“#s1”).val(4)","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery 介绍","date":"2016-07-14T16:00:00.000Z","path":"2016/07/15/JavaScript-14  jQuery01/","text":"jQuery介绍 JavaScript框架库（也叫函数库）：就是一个js文件，这个文件中封装了很多兼容的代码，封装了常用的函数 常用的JavaScript框架库：Prototype、YUI(网络反响一般)、Dojo、ExtJS、jQuery等 jQuery是框架库中的一种，jQuery并不能把所有的浏览器兼容问题全部解决,浏览器兼容不仅是JS还有CSS jQuery优点 write less, do more 体积小，使用简单方便，链式编程，隐式迭代，插件丰富，开源，免费 jQuery中的顶级对象是$，或者是jQuery；页面加载事件 window.onload=function(){};DOM中页面加载的事件,只能一次 $(window).load(function(){})把DOM对象转jQuery对象做页面记载 $(document).read(function(){})jQuery中的页面加载(把DOM转jQuery) jQuery(function(){})jQuery中的加载事件 $(function(){})jQuery中页面事件jQuery对象和DOM对象 jQuery对象只能调用jQuery中的方法 DOM对象只能调用DOM中的属性或者方法 jQuery对象和DOM对象互转 jQuery文件中不能很全面的封装JS的代码(未必通过jQuery来解决所有兼容问题),所以,在写jQuery代码实现功能的时候,有可能通过jQuery无法实现,这个时候就需要通过原生的JS来来实现,由于,jQuery对象只能调用jQuery的方法,所以,需要把jQuery对象转换成DOM对象来实现功能,那么有的时候,通过原生的JS实现功能后,还需要其他的功能,那么,此时DOM对象还需要再次的转换成jQuery对象继续编程 jQUery对象!=(不等于)DOM对象选择器 常用的选择器 id选择器 $(“#id的值”) 标签选择器 $(“标签的名字”) 类选择器 $(“.类样式的名字”) 其他选择器 标签+类选择器 $(“li.cls”) 多条件选择器 $(“p,span,div”) 层级选择器 $(“div p”) 获取的是div中所有的p标签 $(“div *”)：获取div里所有的元素 $(“div&gt;p”) 获取的是div中直接的子元素 $(“div~p”) 获取的是div后面的所有的兄弟元素 $(“div+p”) 获取的是div后面的紧邻着的一个兄弟元素 索引选择器 :eq(索引) 获取的指定索引位置的元素 :lt(索引) 获取的是索引小于目标索引的所有的元素 :gt(索引) 获取的是索引大于目标索引的所有的元素 注意：获取索引大于5小于3的元素是可实现的，获取大于5的元素后，所获取的元素的索引从0开始常用方法 如果括号内不写内容表示的是获取,如果写内容表示设置 .text() innerText .html() innerHTML .val() 和value属性一样 .css() 设置元素样式的方法 :odd() :odd奇数的选择器—但是给用户看的时候是偶数行 :even :even偶数的选择器–但是给用户看的时候是奇数行 .siblings() 获取所有的兄弟元素 .find() 查找元素，如果在括号中写内容就是查找指定的元素 .clone();克隆后的元素样式保留,也可以继续设置样式","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"正则表达式","date":"2016-07-11T16:00:00.000Z","path":"2016/07/12/JavaScript-13  JS进阶和特效03/","text":"概念 正则表达式:首先是一个表达式(可能是单个的元字符组成,也可能是多个的元字符组成),有一定规则,也叫规则表达式。正则表达式的作用:就是用来匹配字符串的。 基本原字符 \\b表示单词的边界 [ .] 干掉元字符原来的意义， { } 表示的是前面的表达式出现的次数 $ 以什么结束 [^] 取反取非 ^ 以什么开头 \\W 特殊符号 [^a-zA-Z__ ] \\w 非特殊符号，包括__（下划线） \\S 非空白符号 \\s 空白符号 \\D 非数字中的一个 \\d 所有数字中的一个 ？ 表示的是该符号前面的第一个表达式出现了零次到1次 第二种作用：阻止贪婪模式 *表示的是该符号前面的第一个表达式出现了零次到多次 +表示的是该符号前面的第一个表达式出现了1次到多次 （ ） 提升优先级别，分组（指的是从左到右）； | 或者，在正则表达式中的优先级别是最低的 [ ] 表示的是范围 [0-9] 指0——9中的一个数字 . 表示的是除了\\n以外的任意一个字符（字符串）正则表达式创建 var reg=new Regxp(/正则表达式/) var reg=/正则表达式/ .text（）方法 ：验证正则表达式和字符串是否匹配，返回值布尔值正则表达式其他使用方式 exec方法是正则表达式对象的一个方法，用来超找指定字符串，返回值是一个数组（找到的对象，索引，整个原字符串）； button获取鼠标的键值 which既能获取鼠标的键值又能获取键盘的键值回车实现文本框跳转123456789//获取所有的文本框var inputs=document.getElementsByTagName(\"input\");for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].onkeydown=function () &#123; if(window.event.keyCode==13)&#123; window.event.keyCode=9; &#125; &#125;&#125;","tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"事件","date":"2016-07-07T16:00:00.000Z","path":"2016/07/08/JavaScript-12  Js进阶和特效02/","text":"概念 事件:就是一件事,有开始有结束,有触发,有响应,事件源(按钮点击等)。 事件的类型如何获取： e.type 注意:没有on注册事件的方式 对象.on+事件名字=事件处理函数 对象.addEventListener（）；火狐谷歌支持，IE8不支持 参数1：事件的类型（事件的名字，没有“on”） 参数2：事件处理函数 参数3：false表示的是事件冒泡,如果是true则是事件捕获 对象.attachEvent（）IE8支持，火狐谷歌不支持 参数1：事件的类型（”on“+事件的名字），有on 参数2：事件处理函数12345678910 //注册事件的兼容代码function addEventListener(element,type,fn)&#123; if(element.addEventListener)&#123; element.addEventListener(type,fn,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(\"on\"+type,fn); &#125;else&#123; element[\"on\"+type]=fn; &#125;&#125; 移除事件的方式 注册事件时用匿名函数，则无法移除； 对象.on+”事件类型”=null; 1234567 例子: my$(\"btn1\").onclick=null; ``` * 对象.removeEventListener() ```javascript 例子: my$(\"btn1\").removeEventListener(\"click\",命名函数,false); 对象.detachEvent() 用指定的方式注册事件,就要用对应的方式移除事件,innerHTML=””不会移除这个元素的事件。12345678910//移除事件的兼容代码 function removeEventListener(element,type,fn) &#123; if(element.removeEventListener)&#123; element.removeEventListener(type,fn,false); &#125;else if(element.detachEvent)&#123; element.detachEvent(\"on\"+type,fn); &#125;else&#123; element[\"on\"+type]=null; &#125; &#125; 注册事件不同方式的区别 方法名不同 参数不同 addEventListener 第一个参数是事件类型（事件名字）没有on 第二个参数是事件处理函数 第三个参数是false atachEvent 第一个参数是事件类型（事件名字），有on 第二个参数是事件处理函数 没有第三个参数 事件执行的时候内部的this指向不同 addEventListener中this是事件源(谁的事件触发了) attachEvent中的this是window 一个有on，一个没有on 兼容问题： addEventListener在谷歌和火狐中都支持,IE11也支持,IE8不支持 attachEvent:IE8支持,谷歌和火狐不支持,IE11也不支持事件冒泡 事件冒泡:元素有嵌套，并且这些元素都注册了相同的事件，里面的元素的事件触发了，外面元素的事件会自动触发。比如说元素A中有一个元素B,如果里面的元素B和外面的元素A都注册了相同的事件,如果里面元素B的该事件触发了,那么外面的元素A的该事件会自动触发。 阻止事件冒泡 window.event.cancelBubble如果是e.cancelBubble火狐也支持 e.stopPropagation(),谷歌和火狐都支持123456789//阻止事件冒泡兼容代码function cancelBubble(e) &#123; e=window.event||e; if(e.stopPropagation)&#123; e.stopPropagation(); &#125;else&#123;//IE8 e.cancelBubble=true; &#125;&#125; 事件的三个阶段 e.eventPhase是可以获取当前的代码是在什么阶段触发的 值是1：捕获阶段 addEventListener()方法，第三个参数表示的是冒泡阶段还是捕获阶段 第三个参数的类型是布尔类型 如果是false，那么就是冒泡阶段 如果是true，则是捕获阶段 冒泡阶段：从里向外 捕获阶段：从外向内 值是2：目标阶段 值是3：冒泡阶段事件源 e.target和window.event.srcElement 事件源(只记住第一个揍我的人) e.currentTarget:当前触发该事件的对象(谁打我我记住谁)iframe标签引入外部的网页1&lt;iframe src=\"http://www.baidu.com\" width=\"80%\" height=\"30%\" frameborder=\"0\"&gt; 表单 表单默认有submit属性 submit标签没有提交的属性，是通过调用form标签的submit属性提交表单的 如果有另外一个标签点击时需要提交，可以调用form表单的onsubmint属性，也可以调用submit标签的属性 将form表单的onsubmint属性移除后，submit及调用提交属性的标签均不能再提交","tags":[{"name":"js进阶","slug":"js进阶","permalink":"http://yoursite.com/tags/js进阶/"}]},{"title":"offset scroll和client","date":"2016-07-04T16:00:00.000Z","path":"2016/07/05/JavaScript-11  Js进阶和特效01/","text":"offset系列基本概念 获取元素实际的宽高，left，top offsetLeft：元素距离左边的距离 offsetTop：元素距离上面的距离 offsetWidth：元素的宽+border offsetHeight：元素的高+border 如果想要获取元素的样式属性实际的值：*window.getComputedStyle()或currentStyle属性 对象.style属性 可以获取属性，也可以设置属性（可读可写） 可以获取在html标签中直接设置的样式的值，获取的都是字符串类型 对象.offset系列属性 获取的是数字类型，没有px offset系列中的属性只能获取值，不能设置值（可读不可写） offsetLeft offsetTop offsetLeft(没有定位)，以body为基准到自身左侧边框(border-left左边)； offsetLeft(有定位)以父元素为基准到自身左侧边框(border-left左边)； offsetLeft=父元素的margin-left+padding-left+border-left; 从body到父元素的margin-left加父元素的padding+父元素的border宽度； offsetWidth offsetHeight offsetWidth和offseHeight是包括元素的边框的 如果元素的样式是在style标签中设置的，只能通过offset系列中的offsetWidth和offseHeight来获取，对象.style是无法获取的； scroll系列基本概念 scroll系列:获取元素的卷曲的值 scrollWidth:获取元素内容的实际的宽度(如果元素非常少就是元素的宽度,如果有滚动条去掉滚动条的宽度) scrollHeight:获取元素内容的实际高度(同上) scrollLeft:获取元素中内容向左卷曲出去的距离,向左滚出去的距离 scrollTop:获取元素中内容向上卷曲出去的距离,向上滚出去的距离 注意点 scrollWidth和scrollHeight：主要是元素中内容的实际高度，与border无关，如果有滚动条，需要去掉滚动条的宽度 scrollHeight：获取元素内容的实际高度，如果元素非常少则是元素的高度，如果有滚动条，需要去掉滚动条的宽度 兼容函数封装123456function getScroll() &#123; return &#123; left: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft || 0, top: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0 &#125;;&#125; client系列基本概念 clientHeight：可视区域的高度 clientWidth：可视区域的宽度 clientY：可视区域的纵坐标 clientX:可视区域的横坐标 e.pageX和e.pageY e.clientX和e.clientY是可视区域的坐标,e.pageX和e.pageY才是真正的文档的坐标pageX和pageY在谷歌和火狐浏览器中都支持,但是在IE8浏览器中不支持12345678910111213141516171819202122232425262728293031//图片跟着鼠标飞document.onmousemove=function (e) &#123; my$(\"im\").style.left=EventTools.getPageX(e)+\"px\"; my$(\"im\").style.top=EventTools.getPageY(e)+\"px\";&#125;;//兼容代码var EventTools=&#123; getEvent:function (e) &#123; //封装事件对象参数:window.event或者e return window.event||e; &#125;, getClientX:function (e) &#123;//封装的是clientX无论是谷歌还是火狐还是IE8 return this.getEvent(e).clientX; &#125;, getClientY:function (e) &#123;//封装的是clientY无论是谷歌还是火狐还是IE8 return this.getEvent(e).clientY; &#125;, getLeft:function () &#123;//获取的是页面的卷曲出去的横坐标 return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0; &#125;, getTop:function () &#123;//获取的是页面的卷曲出去的纵坐标 return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0; &#125;, getPageX:function (e) &#123;//获取的页面的可视区的横坐标+页面卷曲出去的横坐标 return this.getEvent(e).pageX?this.getEvent(e).pageX:this.getClientX(e)+this.getLeft(); &#125;, getPageY:function (e) &#123;//获取的页面的可视区的纵坐标+页面卷曲出去的纵坐标 return this.getEvent(e).pageY?this.getEvent(e).pageY:this.getClientY(e)+this.getTop(); &#125;&#125;; 响应式布局原理1234567891011121314151617181920//获取的可视区域的宽和高 function getClient() &#123; return&#123; //可视区域的宽度 width:window.innerWidth||document.body.clientWidth||document.documentElement.clientWidth||0, //可视区域的高度 height:window.innerHeight||document.body.clientHeight||document.documentElement.clientHeight||0 &#125; &#125; //事件可以检测用户的浏览器的页面的宽度和高度是否发生变化 //只要页面的宽和高发生变化这个事件就会触发 window.onresize=function () &#123; if(getClient().width&gt;960)&#123; console.log(\"您此时用的是电脑浏览的页面\"); &#125;else if(getClient().width&gt;700)&#123; console.log(\"您此时用的是平板浏览的页面\"); &#125;else&#123; console.log(\"您此时用的是手机浏览的页面\"); &#125; &#125;; 通过document直接获取元素 title:document.title 可以获取title标签中的值也可以设置 body:document.body—对象 html:document.documentElement—对象动画函数封装123456789101112131415function animate(element,target) &#123; var timeId=null; timeId=setInterval(function () &#123; var step=8; var current=element.offsetLeft; step=current&lt;target?step:-step; if(Math.abs(target-current)&lt;=Math.abs(step))&#123; clearInterval(timeId); element.style.left=target+\"px\"; &#125;else&#123; current=current+step; element.style.left=current+\"px\"; &#125; &#125;,20); &#125;","tags":[{"name":"js进阶","slug":"js进阶","permalink":"http://yoursite.com/tags/js进阶/"}]},{"title":"BOM","date":"2016-06-30T16:00:00.000Z","path":"2016/07/01/JavaScript-10  BOM/","text":"概述 BOM Browser Object Model 浏览器对象模型 顶级对象 BOM中的顶级对象:window，window对象在代码是可以省略的window下的方法下面的方法返回的是新窗口的对象 window.open(url,target,param); url 要打开的地址 * target新窗口的位置 _blank _self _parent(父框架) * param 新窗口的一些设置 window.close()该方法可以关闭新窗口 location对象 window.location location相当于浏览器地址栏可以将url解析成独立的片段 location对象的属性 href hash 返回url中#后面的内容，包含# host 主机名，包括端口 hostname 主机名 pathname url中的路径部分 protocol 协议 一般是http、https search 查询字符串 location对象的方法 location.href:跳转页面(没有后退) location.assign() 改变浏览器地址栏的地址，并记录到历史中。设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。都有后退的,如果是页面直接加载的时候进行跳转,href和assign方法都看不到后退 location.replace() 替换浏览器地址栏的地址，不会记录到历史中 location.reload() 重新加载navigator对象window.navigator 的一些属性可以获取客户端(浏览器)的一些信息 navigator对象的方法 userAgent platformhistory对象:历史记录 后退 history.back() history.go(-1) 前进 history.forward() history.go(1)页面的加载事件:三个 非常重要的:onload事件:页面内容全部加载完毕，不常用； onunload关闭后触发,IE8支持 onbeforeunload关闭前触发,IE8支持计时器(两个) setInterval();参数:1,函数 2,时间,毫秒,该方法返回的是该计时器的id clearInterval(定时器的id);清理计时器 setTimeout也是定时执行，但是不像setInterval那样是重复的定时执行只执行一次， clearTimeout(timeId)也是清除定时器。","tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"字符串及数组方法","date":"2016-06-27T16:00:00.000Z","path":"2016/06/28/JavaScript-09  DOM04/","text":"字符串字符串特性 特性:不可变性 字符串的变量如果调用了属性或者方法就是基本包装类型对象 字符串中的属性:length,字符串的长度 字符串中的方法 charAt(索引);获取指定索引位置的字符串 charCodeAt(索引);获取的指定索引位置的字符串的ASCII码值 concat(“字符串1”,”字符串2”);拼接字符串的,返回值是拼接后的新的字符串 slice(开始索引,结束索引);从开始索引位置开始截取,到结束索引的位置的前一个结束,返回的是截取后的新的字符串 substring(开始的索引,结束的索引);截取(同上) substr(开始的索引,截取的长度);从指定的索引位置开始截取,截取多少个,返回一个新的字符串 indexOf(“要找的字符串”,开始索引);从开始索引位置查找字符串,找到则返回索引,找不到则返回-1,返回值是索引 lastIndexOf(“要找的字符串”,开始索引);从后面向前面找,索引仍然是从前面开始计算的,找到则返回指定索引,找不到则返回-1 trim();去掉字符串两端的空格,中间的无法去掉 to(Locale)UpperCase() //转换大写 to(Locale)LowerCase() //转换小写 replace(“要替换的字符串”,”新的字符串”);替换字符串的,返回新的字符串 split(“指定的字符串”);是用来切割字符串中指定的字符串的,返回的是字符串的数组 数组数组中的属性:length数组中的常用方法: push(元素);在数组的后面追加一个元素，返回值是追加后的数组的长度 pop();删除数组最后一个元素,返回的是被删除的元素的值 unshift(元素);在数组的前面插入一个元素，返回值是插入后的数组的长度 shift();删除数组第一个元素,返回的是被删除的元素的值 concat(数组1,数组2);拼接数组的 slice(开始的索引,结束的索引);从开始索引位置截取数组元素,到结束索引位置的前一个,返回新的数组 splice(开始的索引,长度);从开始的位置截取数组元素.截取指定长度的个数,返回的是截取后的新的数组 reverse()反转的 sort()排序,一般回传入一个回调函数,可以比较字符串也可以比较数字 indexOf(元素);返回的饿时该元素的索引，如果找不到则返回-1 lastIndexOf(元素);同上 every(函数)方法,判断数组中的每个元素是否符合函数中的判断,如果每个元素都满足条件则返回true,否则返回false map(函数),让数组中的每个元素都执行一次函数,把得到的返回值组成一个新的数组 filter(函数),让数组中的每个元素都要执行函数,把满足条件的元素存放在一个新的数组中 foreach(函数);遍历的 join(字符串);把数组中的每个元素之间用指定的字符串进行连接.返回一个新的字符串 基本包装类型 基本包装类型:String,Number,Boolean 基本类型:string,number,boolean,null,undefined 基本类型变量无法直接调用属性和方法 对象才可以直接调用属性或者方法 Date对象 var dt=new Date();Date方法如下： year=dt.getFullYear(); month=dt.getMonth()+1; day=dt.getDate(); h=dt.getHours(); m=dt.getMinutes(); s=dt.getSeconds();","tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"DOM 元素获取","date":"2016-06-22T16:00:00.000Z","path":"2016/06/23/JavaScript-08  DOM03/","text":"元素样式的获取 style 标签中设置的样式值，通过DOM操作，无法直接获取（外部引入） style 属性中设置的样式值，通过DOM操作，可以直接获取（行内样式） style属性中获取的样式的值都是字符串类型动态创建元素的三种方式 document.write(“标签+内容的代码”)–很少用,一般用在广告的嵌入； 对象.innerHTML=”标签+内容的代码”–一般用在大量字符串拼接创建元素； document.createElement(“标签名字”)–一般用在创建少数元素； 123456789101112131415161718//只能创建一个my$(\"btn\").onclick=function () &#123; //1.无则创建 if(!my$(\"p1\"))&#123;//判断页面中是否存在这个元素,如果存在则结果为true,否则为false var pObj=document.createElement(\"p\"); pObj.id=\"p1\"; pObj.innerText=\"其实\"; my$(\"dv\").appendChild(pObj); &#125; //2.有则删除 if(my$(\"p1\"))&#123; my$(\"dv\").removeChild(my$(\"p1\")); &#125; var pObj=document.createElement(\"p\"); pObj.id=\"p1\"; pObj.innerText=\"其实现在我也喜欢女生\"; my$(\"dv\").appendChild(pObj);&#125;; 元素的添加、删除 父元素.appendChild(创建的子元素)； insetBefore（a,b）第一个参数是刚刚创建的元素，第二个参数是参照元素 replaceChild 1replacedNode = parentNode.replaceChild(newChild, oldChild); removeChild 123var oldChild = node.removeChild(child);ORelement.removeChild(child);","tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"DOM 内容设置及节点介绍","date":"2016-06-20T16:00:00.000Z","path":"2016/06/21/JavaScript-07  DOM02/","text":"innerText和innerHtml的区别 innerHTML和innerText都可以获取标签(元素)中的文本内容 innerHTML可以获取元素中的 标签+文本内容, innerText只能获取文本内容 innerHTML和innerText都可以设置元素中的文本内容 innerHTML可以设置文本内容也可以设置标签+文本内容,innerText只能设置文本,如果设置标签那么会转义 设置和获取自定义属性 自定义属性：html标签本身没有这个属性，我们为了更方便的操作某些元素，自己加的属性； .setAttribute()–设置 .getAttribute()–获取 .cloneNode .cloneNode()方法,参数是布尔类型,如果是true,则会把这个标签中所有的内容全部克隆出来,如果是false,那么只能克隆部分内容; .cloneNode()方法的返回值是节点类型,如果克隆的是标签,那么返回的就是标签(对象) 元素的隐藏方式 display:none; 不占位置 opacity：0；元素透明，占位置 visibility：hidden；占位置 宽高设为0（不常用） 节点 节点：包括 标签 文本 属性； 元素节点： 标签—-元素—–对象 文本节点：文本内容（文字、换行、空格）—–对象 属性节点：标签的属性 只有标签能做父级节点(父级元素)； nodeType(节点类型) 1 代表 元素节点 2 代表 属性节点 3 代表 文本节点 nodeName(节点名字) 如果是标签—-标签的名字 如果是属性—-属性的名字（大写的） 如果是文本—-#text nodeValue(节点的值) 如果当前的节点是标签—-null 如果当前的节点是属性—-属性的值 如果当前的节点是文本—-文本的内容 节点的获取 .firstChild–获取当前元素中的第一个子节点 .firstElementChild–获取当前元素中的第一个子元素 .lastChild–获取当前元素中的最后一个子节点 .lastElementChild–获取当前元素中的最后一个子元素 .parentNode–获取当前元素的父级节点 .parentElement–获取当前元素的父级子元素 .childNodes–获取当前元素的子节点 .children–获取当前元素的子元素 .previousSibling–获取当前元素的前一个兄弟节点 .previousElementSibling–获取当前元素的前一个兄弟元素 .nextSibling–获取当前元素的后一个兄弟节点 .nextElementSibling–获取当前元素的后一个兄弟元素 节点属性的获取 .getAttributeNode() 获取元素的兼容代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//兼容代码//获取任意元素中的第一个子元素function getFirstElement(element) &#123; if(element.firstElementChild)&#123;//浏览器支持这个属性 return element.firstElementChild;//直接返回第一个子元素 &#125;else&#123; var node=element.firstChild;//保存第一个子节点 while (node&amp;&amp;node.nodeType!=1)&#123; node= node.nextSibling; &#125; return node;//这才是第一个子元素(标签) &#125;&#125;//获取任意元素中的最后一个子元素function getLastElement(element) &#123; if(element.lastElementChild)&#123; return element.lastElementChild; &#125;else&#123; var node=element.lastChild; while (node&amp;&amp;node.nodeType!=1)&#123; node=node.previousSibling; &#125; return node; &#125;&#125;//获取任意元素的下一个兄弟元素function getNextElementSibling(element) &#123; if(element.nextElementSibling)&#123; return element.nextElementSibling; &#125;else&#123; var node=element.nextSibling; while(node&amp;&amp;node.nodeType!=1)&#123; node=node.nextSibling; &#125; return node; &#125;&#125;//获取任意元素的前一个兄弟元素function getPreviousElementSibling(element) &#123; if(element.previousElementSibling)&#123; return element.previousElementSibling; &#125;else&#123; var node=element.previousSibling; while(node&amp;&amp;node.nodeType!=1)&#123; node=node.previousSibling; &#125; return node; &#125;&#125;//能力检测获取兄弟元素标签function getSiblings(element) &#123; if(!element)return; var elements=[]; //获取前面的兄弟节点 var ele=element.previousSibling; while(ele)&#123; if(ele.nodeType===1)&#123; elements.push(ele); &#125; ele=ele.previousSibling; &#125; //获取后面的兄弟节点 ele=element.nextSibling; while(ele)&#123; if(ele.nodeType===1)&#123; elements.push(ele); &#125; ele=ele.nextSibling; &#125; return elements;&#125;","tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"DOM 简介","date":"2016-06-17T16:00:00.000Z","path":"2016/06/18/JavaScript-06  DOM01/","text":"DOM相关概念 DOM DOM(文档对象模型)Document-Object-Model。 文档对象模型:一套操作HTML和XML文档的API，就是操作页面元素。 JavaScript最终是要操作Html页面，而操作Html页面就要用到DOM。DOM就是把Html页面模拟成一个对象，如果JavaScript只是执行一些计算、循环等操作，而不能操作Html也就失去了它存在的意义。 DOM可以把HTML和XML描述为一个文档,树上的每一个分支都可以视为一个对象，通过DOM可以添加、修改和移除文档上的某一部分。 文档(Document)：就是指HTML或者XML文件 节点(Node)：HTML文档中的所有内容都可以称之为节点 元素(Element)：HTML文档中的标签可以称为元素,元素称为对象 文档元素(根元素)：文档中的第一个元素，HTML文档元素就是 文本节点：文字内容 属性节点： DOM级别 DOM0 初级阶段 最初浏览器中为了方便检索界面上的元素提供了非常方便的api，查询页面上的元素。实验性质的api称为DOM0 DOM1 规定了节点的类型Node，目前所用的； DOM2:新增了一些方法,但是很多浏览器并不支持 DOM3:大多数浏览器都没有支持 DOM节点获取方式 document.getElementById()–通过id方式获取，获取的是一个元素 document.getElementsByTagName()–通过标签名获取，获取的伪数组 document.getElementsByClassName()–通过类名获取，获取的是伪数组 document.getElementsByName(“name属性的值”)–通过name属性获取，获取的是伪数组 阻止a链接跳转的方式 行内： onclick=”alert();return false” 行内函数：onclick=“return fn（）” fn（）{return false} 函数 id=aa; my$(“aa”).onclick = function {return false} 元素样式的操作方式 对象.style.属性=值 对象.calssName=值 设置元素的选中问题及禁用 input标签中，selected ckecked disabled 的值为true时启用，为false时禁用； innerText和textContent innerText和textContet作用一样,都可以设置元素中的文本内容和获取元素中的文本内容 innerText原本是IE8浏览器中支持的一个属性 textContent原本是火狐浏览器中支持的一个属性 现在,目前谷歌和火狐和IE8都支持innerText 谷歌和火狐都支持textContent123456789101112131415161718192021//设置任何元素的文本内容//能力检测function setInnerText(element,content) &#123; if(element.textContent==undefined)&#123; //IE8没有这个属性 element.innerText=content; &#125;else&#123; //不是IE8,要么是谷歌要么是火狐 element.textContent=content; &#125;&#125;//获取任何元素的文本内容function getInnerText(element) &#123; if(element.textContent==undefined)&#123; //IE8没有这个属性 return element.innerText; &#125;else&#123; //不是IE8,要么是谷歌要么是火狐 return element.textContent; &#125;&#125; 事件 事件：触发，响应，触发事件的事件源； 注册事件: 在html标签中 on事件名字=”js代码(函数调用)”12&lt;input type=\"button\" value=\"按钮\" onclick=\"alert('啊哈哈');\"/&gt;&lt;input type=\"button\" value=\"按钮\" onclick=\"f1();\"/&gt; 在script标签中获取元素注册事件 对象.on事件名=匿名函数; 匿名函数也叫事件处理函数 123 &lt;script&gt; document.getElementById(\"btn\").onclick=function()&#123;&#125;&lt;/script&gt; 在script标签获取元素注册事件—-采用命名函数 1234 &lt;script&gt; document.getElementById(\"btn\").onclick=clickHandle; function clickHandle()&#123;&#125;;&lt;/script&gt;","tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"对象","date":"2016-06-14T16:00:00.000Z","path":"2016/06/15/JavaScript-05  对象/","text":"对象是什么 JavaScript中的对象：无序属性的集合。 其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。 对象的行为和特征 特征—属性 行为—方法面向对象和基于对象 面向对象：可以创建自定义的类型、很好的支持继承和多态。面向对象的语言c++/java/c#… 面向对象的特征：封装、继承、多态 万物皆对象：世间的一切事物都可以用对象来描述 基于对象：无法创建自定义的类型、不能很好的支持继承和多态。基于对象的语言JavaScript; 创建对象1234var obj = new Object();构造函数，创建对象。1.首字母大写； 2.函数用new调用执行； 属性绑定 对象名.属性=属性值(除了函数)，对象名.方法=函数。 123456obj.name = \"李四\";obj.age = 20;obj.fn = function () &#123; console.log(obj.name+\":我是李四！\");&#125; 对象名[字符串/数值/boolean]=值, 对象名[变量]=值。优点在于更灵活。可以随意绑定任意变量的值，作为属性。 1234567891011//利用变量绑定属性。var aaa = \"name\";obj.aaa = \"李四\";obj[aaa] = \"李四\";//当绑定数组中的元素作为属性的时候，对象名.属性这种方法就不能用了。//只能用对象名[变量]var arr = [\"aaa\",\"bbb\",\"ccc\"]for(var i=1;i&lt;=3;i++)&#123; var str = arr[i-1]; obj[str] = i;&#125; 创建自定义对象1234567891011121314151617181920// 需求：创建多个自定义对象，要有属性和方法，将来方便操作// 思路：封装一个方法：功能是，创建一个空白对象，然后为他绑定属性和方法。 //通过函数创建对象。 var stu1 = createStu(\"拴住儿\",45); var stu2 = createStu(\"铁锤\",25); var stu3 = createStu(\"狗剩儿\",18); //步骤： function createStu(name,age)&#123; var stu = new Object(); //绑定属性和方法，让他看起来更像一个学生对象。 stu.name = name; stu.age = age; //绑定方法 stu.study = function () &#123; //this函数的调用者 console.log(this.name +\":(已经12点了)扶我起来，我还要敲代码....\"); &#125; //每次调用这个方法，都能穿件一个新的对象并把他返回。 return stu; &#125; new和this var obj = new Object(); new一共做了3件事。 开辟了一块儿，内存空间。然后把对象放入其中。 把this指向当前对象。 把对象返回。 this一共做了3件事。 this只出现在函数中。（类似arguments） this代指函数的调用者。 new Object(); this代指被创建出来的对象。jsonjson就是对象。但是，对象不一定是json。 json的属性值一般是字符串。jQuery1.7… ajax如果属性不是字符串无法识别。 json,数组也好。他们的属性值都可以是任何类型。可以相互嵌套。 json的格式可以写为： {key1:value1,key2:value2…..} {k1:v1,k2:v2…}; json遍历使用for…in… 12345for(var k in aaa)&#123; //1.k代表json中的所有属性 //2.json[k]代表json中的所有属性值. // 第二种属性绑定，可以放入变量的那种。&#125;","tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"函数","date":"2016-06-11T16:00:00.000Z","path":"2016/06/12/JavaScript-04  函数/","text":"函数的定义 函数就是可以重复执行的代码块。函数的定义有两种方式： 函数声明 1234567function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; 函数表达式 1234567var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; 函数的参数 函数中的参数是按值传递的，可以看成局部变量。 形参形式上参与运算的变量，无实际值，为实参占位置，就像一个躯壳一样（可以理解为函数的内部变量外部无法访问）。 实参实际参与运算的变量。形参为他占位置，真实参与运算的变量。 形参和实参个数问题 实参比形参多：正常执行，多出来的元素，不用。 实参等于形参：正常执行。 实参比形参少：如果不传值，默认是undefined，是否报错取决于程序；函数的返回值有return函数就有值；没有return函数就没有值。函数内部，return后面的值就是返回值； 如果函数没有使用 return ，那么函数有默认的返回值：undefined 如果函数使用 return，那么跟再return后面的值，就成了函数的返回值； 如果函数使用 return，但是return后面没有任何值，那么函数的返回值也是：undefined； 函数使用return后，这个函数会在执行完 return 语句之后停止并立即退 出，也就是说return后面的所有其他代码都不会再执行。函数加载函数名和函数体1234567function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; function指出这是一个函数定义； abs是函数的名称； (x)括号内列出函数的参数，多个参数以,分隔； { … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。函数加载 JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。 变量和作用域作用域变量作用域在JavaScript中，用var申明的变量实际上是有作用域的。 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量： 12345function foo() &#123; var x = 1; x = x + 1;&#125;x = x + 2; // ReferenceError! 无法在函数体外引用变量x 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响： 123456789function foo() &#123; var x = 1; x = x + 1;&#125;function bar() &#123; var x = 'A'; x = x + 'B';&#125; 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行： 1234567function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; 如果内部函数和外部函数的变量名重名怎么办？ 12345678910function foo() &#123; var x = 1; function bar() &#123; var x = 'A'; alert('x in bar() = ' + x); // 'A' &#125; alert('x in foo() = ' + x); // 1 bar();&#125;这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 全局作用域 不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：1234var course = 'Learn JavaScript';alert(course); // 'Learn JavaScript'alert(window.course); // 'Learn JavaScript'因此，直接访问全局变量course和访问window.course是完全一样的。 JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 局部作用域由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：123456function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 全局变量和局部变量 全局变量 哪里都可以访问到的变量(进入script立即定义的变量和没有var的变量)； 局部变量 函数内部的变量，只有函数内部可以访问到(函数内部用var定义的变量和形参)。 隐式全局变量隐式全局变量就是隐藏的全局变量不好被发现。 123456789function fn（）&#123;var a = b = c = 1; // b和c就是隐式全局变量&#125;注意:function fn（）&#123;var a = b = c = 1; // b和c就是隐式全局变量（等号）var a = 1; b = 2; c = 3; // b和c就是隐式全局变量（分号）var a = 1 , b = 2 , c = 3; // b和c就不是隐式全局变量（逗号）&#125; 变量声明提升(出现原因：预解析) 变量声明提升：在预解析的时候，全局变量和函数，被提升到最高位置，方便其他程序访问； 变量声明提升特点：全局变量只提升变量名，不提升变量值。函数的所有内容全部提升(function直接定义的)； 先提升全局变量，后提升函数； 函数范围内照样会出现变量声明提升；知识补充 函数不调用不执行 函数名就等于（整个函数） 加载函数的时候，只加载函数名，不加载函数体 就近原则使用变量 两个平级的函数中的变量不会相互影响（可以使用同样的形参名） javascript中函数不能重载。函数高级函数的三个高级操作 回调函数:函数作为参数 1234567fn(demo3);//一定要加函数名或者这个函数体。千万不能直接执行函数。否则放的是返回值。function fn(aaa)&#123; aaa();//一旦参数名后面加(),那么这个参数一定是函数,这种函数叫做回调函数。 &#125; function demo3()&#123; alert(1); &#125; 递归：函数自己调用自己 递归必须有跳出条件，否则没有意义(死循环); 123456789var num = 1;fn();function fn()&#123; console.log(\"从前有座山.....\"); num++; if(num&lt;5)&#123; fn(); &#125;&#125; 闭包：返回值是函数 12345678910var demo = fn();demo();function fn()&#123; var aaa = 111; return function () &#123; alert(\"我是aaa对应的值：\"+aaa); &#125;&#125;","tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"数组","date":"2016-06-09T16:00:00.000Z","path":"2016/06/10/JavaScript-03  数组/","text":"数组概述数组是什么数据的有序列表，可以存放任意类型的数据，数组的大小可以动态调整。 数组的定义数组的定义(创建数组)有两种方式： 字面量定义 12345678910 var arr = [1,2,3]; ``` &lt;!-- more --&gt;* 对象定义(数组的构造函数) ```js var arr = new Array(参数); 参数位置一个数值时为数组长度，多个数值时为数组中的元素。 数组的操作求数组的长度 数组的长度=数组名.length; 可以通过修改数组的长度来改变数组中元素的个数，如果改小了，数组从后面删除元素。（伪数组的长度可以修改，但是不能修改里面的元素）获取数组中的元素数组中的指定元素 = 数组名[索引值]; 数组的索引代表的是数组中的元素在数组中的位置，从0开始。 如果获取数组中元素是，数组名[索引值]，没有指定索引（元素没那么多），系统不报错，而是给定值为undefined；遍历数组1234var arr=[1,2,3];for(var i=0;i&lt;arr.length;i++) &#123; arr[i] // 如此操作数组中的每一个元素&#125;","tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"Javascript 基础知识","date":"2016-06-05T16:00:00.000Z","path":"2016/06/06/JavaScript-0201  JavaScript数据类型/","text":"数据类型数据类型的划分 简单数据类型(值类型) number-数值型 string-字符型 boolean-布尔型 undefined-未定义数据类型 null-空型 复杂数据类型(引用类型) Object、function、Array、Date、RegExp等； 数据类型检测 使用typeof操作符检测，使用方法：typeof name 或者 typeof(name); Number 类型 进制：包括2进制、8进制（011）、10进制、16进制（0xa）、32进制等…. 浮点数：因为精度丢失问题，所以不判断计算后的两个浮点数是否相等。 数值范围:由于内存的限制，ECMAScript 并不能保存世界上所有的数值。 最小值：Number.MIN_VALUE，这个值为： 5e-324 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 无穷大：Infinity 无穷小：-Infinity NaN NaN 非数值（Not a Number的简写） console.log(“abc”/18); //结果是NaN; Undefined和任何数值计算为NaN; NaN 与任何值都不相等，包括 NaN 本身; isNaN() :任何不能被转换为数值的值都会导致这个函数返回 true （isNaN译为是否符合一个标准，什么标准呢？不是一个数字的标准，如果符合了那么就不是一个数字，不符合就是一个数字） isNaN(NaN);// true isNaN(“blue”); // true isNaN(123); // false String 类型 字面量定义方式 用引号时，可单可双，唯独不可一单一双。可用.length看有几个字符。 123var name = \"zhangsan\";var name = 'zhangsan';var name = 'zhangsan\"; //错误，单引号和双引号要成对出现 转译 总结：无法输出的字符，先输出/，在输出字符。（“、\\、换行等….） 字符串不可变 在内存中不会立刻消失，只能二次赋值，原有的字符在一定时间内被垃圾回收器回收。 字符串拼接 如果两个变量都是字符串，无论是否包含数字，只要是拼接，那么在前一个后面添加后一个字符串。（+与-情况不同，详情参考数据转换） Boolean 类型 Boolean类型有两个字面量：true和false，区分大小写。（大写不对） 虽然Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值 true true、除0数字、“something”、Object(任何对象)为true false false、0 、“”、undefined 、null为false if判断时会把（）内的值强行转换成boolean类型。 Undefined和Null 类型 Undefined是一种比较特殊的类型，表示变量未赋值，这种类型只有一种值就是undefined. Null是第二个只有一个值的数据类型，这个特殊的值是null. 从逻辑角度看，null值表示一个空对象指针，使用typeof检测null值时返回object。 如果定义的变量准备在将来用于保存对象，最好将该变量初始化为null而不是其他值。 Undefined和Null的异同 null和undefined有最大的相似性。看看null == undefined的结果(true)也就更加能说明这点。但是null ===undefined的结果(false)。不过相似归相似，还是有区别的，就是和数字运算时，10 + null结果为：10；10 + undefined结果为：NaN。 任何数据类型和undefined运算都是NaN; 任何值和null运算，null可看做0运算。 数据类型的转换转换成String类型 变量+“” 或者 变量+“abc”; String(变量); 变量.toSting() 注意：undefined和null不可以 Null和undefined无toString方法。 换成Number类型 此转换容易产生NaN，一旦被转换的变量中含有非数字字符，都容易出现NaN 变量-*/一个数字（有非数字字符会出现NaN） 123var num1 =“11”- 0; var num2 =“11”* 1;var num =“11”/1; JS底层做了一个强制类型转换，把字符串转换成了Number进行运算。 Number(变量)（有非数字字符会出现NaN） 12var num1 = Number(“18”); 把字符变成了数字。var num2 = Number(“18.99”); 结果为18.99数字型。（有小数也转换） parseInt()和parseFloat()（译为取整和取浮点数） 空字符串parseInt()和parseFloat()返回NaN，Number(“”)返回0; parseInt(变量)：如果变量中收割字符为字母则结果为NaN,否则取出现首个非数字前的整数。 1123 = parseInt(“123.123aaaa”); parseFloat(变量)：如果变量中收割字符为字母则结果为NaN,否则取出现首个非数字前的浮点数。（没有小数取整） 1123.123 = parseFloat(“123.123aaaa”); 提别提示 Boolean类型中：true数值为1；false为0； null的数值类型为0； undefined无数值类型或者为NaN; 任何简单类型转换成Boolean类型 任何数据类型都可以转换成boolean类型; Boolean(变量) 1var bool = Boolean(“1111”); bool为true； ！！变量 第一个逻辑非操作会基于无论什么操作数返回一个与之相反的布尔值 第二个逻辑非操作则对该布尔值求反 于是就得到了这个值真正对应的布尔值 操作符操作符种类 算数运算符（+—*/…） 一元运算符：正号、负号、++、–、平方等一个变量就能运算 ++前置：先自加，后运算； ++后置：先运算，后自加； 二元运算符：+-*/%等两个变量才能运算 三元运算符：值1？值2：值3； 逻辑运算符（ || &amp;&amp; ! ）（ 或 与 非） 比较运算符（&lt;、&gt;、==、&gt;=…） 赋值运算符（=、+=、-=、*=、/=、%=） 优先级 () !、-（负数）、++、– （正数省略+）（一元运算） *、/、% +、- （加，减）（二元运算） &lt;、&lt;=、&lt;、&gt;= （一级逻辑运算） ==、!=、===、!==、 （二级逻辑运算） &amp;&amp; （三级级逻辑运算） || ?: （三元运算） =、+=、-=、*=、/=、%= （赋值运算） &amp;&amp;和||运算（短路运算） &amp;&amp;链接两个boolean类型，有一个是false结果就是false。 链接值不是布尔类型时，按照成布尔类型计算，结果本身不变。（非布尔） 如果不是boolean类型值，会按照对应的布尔类型之计算，然后返回的值不变。1例子： 1 = 2&amp;&amp;1；0 = 0 &amp;&amp; 1；都是true取后面，都是false取前面。 ||链接两个boolean类型，有一个是true结果就是true。 链接值不是布尔类型时，按照成布尔类型计算，结果本身不变。（非布尔） 如果不是boolean类型值，会按照对应的布尔类型之计算，然后返回的值不变。1例子： 2= 2||1；1 = 0 || 1；都是true取前面，都是false取后面。 流程控制循序结构 程序正常执行顺序。 选择结构共有两种，if语句和switch语句。if常用，switch为特殊情况使用，判断条件出现的情况特别多的时候用switch，其他时候if语句比较方便。 if语句 If语句用法有三种 if(条件1){程序1} if(条件1){程序1}else{程序2} if(条件1){程序1}else if(条件2){程序2}…else{程序n} 三目运算（也叫三元运算）（目或者元代表几个表达式）三目运算可以替代部分if…else…功能，运算简单，使用方便，代码清晰。表达式1？值1：值2Switch语句1234567891011121314switch (值1) &#123; case value1: 程序1； break; // break 关键字会导致代码执行流跳出 switch 语句 case value2: 程序2； break; default: 程序3；&#125;注意：break不可以省略，如果省略，代码会继续执行下一个case。switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串 \"10\" 不等于数值 10）。 循环结构 共3种，for/while/do…while；可根据需求选择使用； 遍历数组首选for循环，简单循环使用for。 while循环强调，不记循环次数（不知道循环多少次），首选while。 最后do…while循环强调，无论怎样，至少执行一次是，使用do…while。for循环 执行流程 for (变量;条件1;条件2){ 执行程序 } 执行过程：变量-&gt;条件1-&gt;执行程序-&gt;条件2-&gt;条件1-&gt;执行程序….. 直到条件1不成立，跳出循环。 三个表达式均为可选，但是必须写分号！！！ for(;;){程序} 死循环; break和continue break-立即退出循环； continue-立即退出当前循环，但退出循环后会从循环的顶部继续执行；while循环语法规则：1234var i = 0;while(i&lt;10)&#123;程序1；i++&#125;; 可以使用死循环和break连用。While(true)(程序1; if(条件1)&#123;break;&#125;) do…while循环（一定会执行一次do中的程序）12345var i = 0；Do&#123;程序1；i++;&#125;while(1&lt;10);","tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"Javascript 基础知识","date":"2016-06-04T16:00:00.000Z","path":"2016/06/05/JavaScript-02  JavaScript入门/","text":"JavaScript 书写位置在HTML页面中书写JSJavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到&lt;head&gt;中： 12345678910&lt;html&gt; &lt;head&gt; &lt;script&gt; alert('Hello, world'); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 引入外部.js文件12345678&lt;html&gt; &lt;head&gt; &lt;script src=\"/static/js/abc.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; JavaScript依上自下依次执行，外部引入写在&lt;/body&gt;前。 语法基本语法JavaScript的语法大量借鉴C及其他类C语言的语法，语法宽松。每个语句以`;`结束，语句块用`{...}`。但是，JavaScript并不强制要求在每个语句的结尾加`;`，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上`;`。 注释单行注释：以两个斜杠开头 1//单行注释 块级注释：以一个斜杠跟一个星开头(/*)，以一个星和一个斜杠结束(*/)。 123/* * 多行(块级)注释*/ 严格区分大小写JavaScript中的一切(变量、函数名和操作符)都区分大小写。 变量 变量是计算机中存储数据的一个标识符。JavaScript的变量是松散型，可以用来保存任何数据类型的数据，定义变量使用var操作符； 变量的命名规范 采用驼峰命名，一般使用字母、数字、$、下划线； 不能超过255字符； 不能有空格； 不能使用关键字、保留字； 大小写完全区分；","tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"Javascript 简介","date":"2016-05-27T16:00:00.000Z","path":"2016/05/28/JavaScript-01  JavaScript 简介/","text":"JavaScript-01 JavaScript 简介JavaScript是什么JavaScript是世界上用的最多的，一种客户端的脚本语言。脚本语言：不需要编译，直接运行时边解析边执行的语言。 JavaScript的历史JavaScript诞生于1995年。主要目的是处理以前由服务器端语言负责的一些输入验证操作。 当时工作于 Netscape 的 Brendan Eich，开始着手为即将在 1995 年发行的 Netscape Navigator 2.0 开发一个称之为 LiveScript 的脚本语言，当时的目的是在浏览器和服务器（本来要叫它 LiveWire）端使用它。Netscape 与 Sun 及时完成 LiveScript 实现。就在 Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript，目的是为了利用 Java 这个因特网时髦词汇。Netscape 的赌注最终得到回报，JavaScript 从此变成了因特网的必备组件。 因为 JavaScript 1.0 如此成功，Netscape 在 Netscape Navigator 3.0 中发布了 1.1 版。恰巧那个时候，微软决定进军浏览器，发布了 IE 3.0 并搭载了一个 JavaScript 的克隆版，叫做 JScript（这样命名是为了避免与 Netscape 潜在的许可纠纷）。微软步入 Web 浏览器领域的这重要一步虽然令其声名狼藉，但也成为 JavaScript 语言发展过程中的重要一步。 在微软进入后，有 3 种不同的 JavaScript 版本同时存在：Netscape Navigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase。与 C 和其他编程语言不同的是，JavaScript 并没有一个标准来统一其语法或特性，而这 3 中不同的版本恰恰突出了这个问题。随着业界担心的增加，这个语言的标准化显然已经势在必行。 JavaScript实现一个完整的JavaScript实现应该由以下三个部分组成：核心：ECMAScript–JavaScript的语法规范；文档对象模型：DOM–JavaScript操作网页上元素的API；浏览器对象模型：BOM–JavaScript操作浏览器部分功能的API；","tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]}]